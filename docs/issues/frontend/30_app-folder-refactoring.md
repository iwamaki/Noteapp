---
title: "appフォルダのリファクタリング"
id: 30
status: new
priority: medium
attempt_count: 0
tags: [refactoring, architecture, frontend, code-quality]
---

## 概要 (Overview)

`app`フォルダ内のコードベースの品質、保守性、拡張性を向上させるためのリファクタリングを実施します。これにより、将来的な機能追加や変更が容易になり、開発効率の向上を目指します。

## 背景 (Background)

現在の`app`フォルダには、開発の過程で以下のような課題が生じている可能性があります。

*   責務が不明確なファイルやコンポーネントが存在する。
*   命名規則に一貫性がなく、コードの可読性が低い。
*   重複したコードやロジックが存在し、保守が困難になっている。
*   コンポーネントの再利用性が低い。
*   依存関係が複雑化し、変更が他の部分に予期せぬ影響を与えるリスクがある。

これらの課題を解決し、より堅牢で持続可能なコードベースを構築するために、本リファクタリングを実施します。

## 受け入れ条件 (Acceptance Criteria)

- [ ] `app`フォルダ内の各ファイルおよびディレクトリの責務が明確に分離されていること。
- [ ] プロジェクト全体で統一された命名規則が適用され、コードの可読性が向上していること。
- [ ] 重複するコードやロジックが特定され、適切に抽象化または削除されていること。
- [ ] コンポーネントの再利用性が向上していること。
- [ ] 既存の機能がリファクタリング後も全て正常に動作すること（既存のテストが全てパスすること）。
- [ ] UI/UXに意図しない変更がないこと。
- [ ] コードレビューにおいて、リファクタリングの目的が達成されていると承認されること。

## 関連ファイル (Related Files)

- `app/` (appフォルダ内の全てのファイルとサブディレクトリ)

## 制約条件 (Constraints)

- 既存の機能の動作やユーザー体験に影響を与えないこと。
- リファクタリング中に新たなバグを導入しないこと。
- TypeScriptの型安全性を維持し、Any型の不必要な使用を避けること。
- React Nativeのベストプラクティスおよび既存のアーキテクチャパターンに従うこと。
- パフォーマンスに悪影響を与えないこと。

## 開発ログ (Development Log)

---
### 試行 #1

- **試みたこと:** （実行した計画の要約）
- **結果:** （成功、失敗、発生したエラーなど）
- **メモ:** （次のセッションへの申し送り事項、気づきなど）

---

## 現状分析

### NoteListScreen.tsx の分析

#### 概要
`NoteListScreen.tsx` は、ノート一覧画面の表示、選択モードの管理、新規ノートの作成、および選択されたノートの操作（削除、コピー）を担当しています。多くのロジックとUI要素を含んでいます。

#### 「コードの臭い」とリファクタリングの候補
1.  **単一責任の原則の違反**:
    *   ノートの表示、選択モードの管理、ヘッダーの動的な変更、ノートの作成・削除・コピーといった複数の責任を負っており、コンポーネントが肥大化しています。
2.  **ロジックとUIの混在**:
    *   `handleSelectNote`、`handleLongPressNote`、`handleCancelSelection`、`handleDeleteSelected`、`handleCopySelected`、`handleCreateNote` といったイベントハンドラがコンポーネント内に直接定義されており、ロジックとUIの記述が密接に結合しています。
3.  **`useLayoutEffect` の複雑さ**:
    *   `useLayoutEffect` 内でヘッダーのオプションを動的に設定するロジックが比較的複雑です。選択モードの有無によって、表示されるボタンやタイトルが大きく変わります。
4.  **デバッグ用ログの存在**:
    *   `console.log` がいくつか残っており、本番環境では不要です。

#### リファクタリングの提案
1.  **カスタムフックへのロジックの抽出**:
    *   **`useNoteListActions` (仮称)**: ノートの選択、削除、コピー、作成といったアクションに関するロジックをカスタムフックに抽出します。
    *   **`useNoteListHeader` (仮称)**: ヘッダーの動的な設定ロジックをカスタムフックに抽出します。
2.  **デバッグ用ログの削除**:
    *   残っている `console.log` ステートメントを削除します。

### NoteEditScreen.tsx の分析

#### 概要
`NoteEditScreen.tsx` は、ノート編集画面の表示、タイトルと内容の編集、プレビュー表示、変更の保存、バージョン履歴へのアクセス、そしてLLMコマンドの処理といった、多くの機能とロジックを含んでいます。

#### 「コードの臭い」とリファクタリングの候補
1.  **単一責任の原則の違反**:
    *   ノートのデータ管理（`useNoteEditor` を通じて）、ビューモードの管理、ヘッダーの動的な変更、LLMコマンドの処理といった複数の責任を負っており、コンポーネントが肥大化しています。
2.  **`useLayoutEffect` の複雑さ**:
    *   `useLayoutEffect` 内でヘッダーのオプションを動的に設定するロジックが非常に複雑です。ビューモード (`edit`, `preview`, `content`) やローディング状態 (`isLoading`) に応じて、表示されるボタンやタイトル（`TextInput` を含む）が大きく変わります。
3.  **LLM関連ロジックの結合**:
    *   `handleCommandReceived` 関数と `useLLMCommandHandler` の初期化が `NoteEditScreen` 内に直接記述されており、LLMコマンドの処理ロジックがコンポーネントに結合しています。
4.  **`ChatContext` の構築**:
    *   `chatContext` オブジェクトの構築ロジックがコンポーネント内にあります。これは比較的シンプルですが、将来的に複雑になる可能性もあります。

#### リファクタリングの提案
1.  **カスタムフックへのロジックの抽出**:
    *   **`useNoteEditHeader` (仮称)**: ヘッダーの動的な設定ロジックをカスタムフックに抽出します。
    *   **`useNoteLLMIntegration` (仮称)**: LLMコマンドの処理をカスタムフックに抽出します。
2.  **`ChatContext` 構築の分離**:
    *   `chatContext` の構築ロジックを、もし複雑になるようであれば、専用のヘルパー関数やカスタムフックに分離することも検討できます。




